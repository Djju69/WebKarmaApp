"""
Telegram bot command handlers for loyalty system.
"""
from typing import Dict, Any, Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import CallbackContext, CommandHandler, CallbackQueryHandler
from sqlalchemy.orm import Session

from app.db.base import get_db
from app.services.loyalty.service import LoyaltyService
from app.core.security import get_current_user
from app.models.user import User

class LoyaltyCommandHandlers:
    """Handlers for loyalty-related Telegram commands."""
    
    def __init__(self):
        self.commands = [
            ('balance', self.show_balance),
            ('earn', self.earn_points),
            ('spend', self.spend_points),
            ('history', self.show_history),
            ('help_loyalty', self.help_loyalty)
        ]
        
        self.callbacks = {
            'loyalty_earn': self.handle_earn_callback,
            'loyalty_spend': self.handle_spend_callback,
            'loyalty_history': self.handle_history_callback
        }
    
    async def show_balance(self, update: Update, context: CallbackContext) -> None:
        """Show user's loyalty points balance and tier."""
        db = next(get_db())
        try:
            # Get user from database
            user = db.query(User).filter(
                User.telegram_id == update.effective_user.id
            ).first()
            
            if not user:
                await update.message.reply_text(
                    "‚ùå –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Å–∏—Å—Ç–µ–º–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏."
                )
                return
            
            # Get loyalty account info
            service = LoyaltyService(db)
            account_info = service.get_account_summary(user.id)
            
            # Format response
            response = (
                f"üíé *–í–∞—à –±–∞–ª–∞–Ω—Å* üíé\n\n"
                f"üîπ –ë–∞–ª–∞–Ω—Å: *{account_info['points']}* –±–∞–ª–ª–æ–≤\n"
                f"üèÜ –£—Ä–æ–≤–µ–Ω—å: *{account_info['tier_name']}*\n"
                f"üìà –î–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è: *{account_info['points_to_next_tier']}* –±–∞–ª–ª–æ–≤\n"
                f"üéÅ –ë–æ–Ω—É—Å: *{account_info['tier_discount']}%* —Å–∫–∏–¥–∫–∞"
            )
            
            await update.message.reply_text(
                response,
                parse_mode='Markdown'
            )
            
        except Exception as e:
            logger.error(f"Error in show_balance: {e}")
            await update.message.reply_text(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–∞–ª–∞–Ω—Å–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )
        finally:
            db.close()
    
    async def earn_points(self, update: Update, context: CallbackContext) -> None:
        """Handle /earn command to add points to user's account."""
        if not context.args or len(context.args) < 1:
            await update.message.reply_text(
                "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /earn <–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ_–±–∞–ª–ª–æ–≤> [–ø—Ä–∏—á–∏–Ω–∞]"
            )
            return
            
        try:
            points = int(context.args[0])
            reason = ' '.join(context.args[1:]) if len(context.args) > 1 else None
            
            db = next(get_db())
            try:
                # Get user from database
                user = db.query(User).filter(
                    User.telegram_id == update.effective_user.id
                ).first()
                
                if not user:
                    await update.message.reply_text(
                        "‚ùå –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Å–∏—Å—Ç–µ–º–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏."
                    )
                    return
                
                # Add points
                service = LoyaltyService(db)
                transaction = service.add_points(
                    user_id=user.id,
                    points=points,
                    reason=reason,
                    created_by=user.id
                )
                
                # Get updated balance
                account_info = service.get_account_summary(user.id)
                
                # Format response
                response = (
                    f"‚úÖ –ù–∞—á–∏—Å–ª–µ–Ω–æ *{points}* –±–∞–ª–ª–æ–≤\n"
                    f"üí≥ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: *{account_info['points']}* –±–∞–ª–ª–æ–≤\n"
                    f"üèÜ –£—Ä–æ–≤–µ–Ω—å: *{account_info['tier_name']}*"
                )
                
                if reason:
                    response += f"\nüìù –ü—Ä–∏—á–∏–Ω–∞: {reason}"
                
                await update.message.reply_text(
                    response,
                    parse_mode='Markdown'
                )
                
            except Exception as e:
                db.rollback()
                logger.error(f"Error in earn_points: {e}")
                await update.message.reply_text(
                    "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –±–∞–ª–ª–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                )
            finally:
                db.close()
                
        except ValueError:
            await update.message.reply_text(
                "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –±–∞–ª–ª–æ–≤. –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ."
            )
    
    async def spend_points(self, update: Update, context: CallbackContext) -> None:
        """Handle /spend command to deduct points from user's account."""
        if not context.args or len(context.args) < 1:
            await update.message.reply_text(
                "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /spend <–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ_–±–∞–ª–ª–æ–≤> [–ø—Ä–∏—á–∏–Ω–∞]"
            )
            return
            
        try:
            points = int(context.args[0])
            reason = ' '.join(context.args[1:]) if len(context.args) > 1 else None
            
            db = next(get_db())
            try:
                # Get user from database
                user = db.query(User).filter(
                    User.telegram_id == update.effective_user.id
                ).first()
                
                if not user:
                    await update.message.reply_text(
                        "‚ùå –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Å–∏—Å—Ç–µ–º–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏."
                    )
                    return
                
                # Spend points
                service = LoyaltyService(db)
                try:
                    transaction = service.spend_points(
                        user_id=user.id,
                        points=points,
                        reason=reason,
                        created_by=user.id
                    )
                    
                    # Get updated balance
                    account_info = service.get_account_summary(user.id)
                    
                    # Format response
                    response = (
                        f"‚úÖ –°–ø–∏—Å–∞–Ω–æ *{points}* –±–∞–ª–ª–æ–≤\n"
                        f"üí≥ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: *{account_info['points']}* –±–∞–ª–ª–æ–≤\n"
                        f"üèÜ –£—Ä–æ–≤–µ–Ω—å: *{account_info['tier_name']}*"
                    )
                    
                    if reason:
                        response += f"\nüìù –ü—Ä–∏—á–∏–Ω–∞: {reason}"
                    
                    await update.message.reply_text(
                        response,
                        parse_mode='Markdown'
                    )
                    
                except ValueError as e:
                    await update.message.reply_text(f"‚ùå {str(e)}")
                    
            except Exception as e:
                db.rollback()
                logger.error(f"Error in spend_points: {e}")
                await update.message.reply_text(
                    "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏ –±–∞–ª–ª–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                )
            finally:
                db.close()
                
        except ValueError:
            await update.message.reply_text(
                "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –±–∞–ª–ª–æ–≤. –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ."
            )
    
    async def show_history(self, update: Update, context: CallbackContext) -> None:
        """Show user's transaction history."""
        db = next(get_db())
        try:
            user = db.query(User).filter(
                User.telegram_id == update.effective_user.id
            ).first()
            
            if not user:
                await update.message.reply_text(
                    "‚ùå –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Å–∏—Å—Ç–µ–º–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏."
                )
                return
            
            # Get transaction history
            service = LoyaltyService(db)
            transactions = service.get_transaction_history(user.id, limit=10)
            
            if not transactions:
                await update.message.reply_text("üìú –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏–π –ø–æ –±–æ–Ω—É—Å–Ω–æ–º—É —Å—á—ë—Ç—É.")
                return
            
            # Format response
            response = "üìú *–ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π*\n\n"
            
            for i, tx in enumerate(transactions, 1):
                tx_type = "‚ûï –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ" if tx.points > 0 else "‚ûñ –°–ø–∏—Å–∞–Ω–∏–µ"
                response += (
                    f"{i}. *{tx_type}*\n"
                    f"   üí∞ *{abs(tx.points)}* –±–∞–ª–ª–æ–≤\n"
                    f"   üìÖ {tx.created_at.strftime('%d.%m.%Y %H:%M')}\n"
                )
                
                if tx.reason:
                    response += f"   üìù {tx.reason}\n"
                
                response += "\n"
            
            # Add pagination buttons if needed
            keyboard = [
                [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="loyalty_history:prev"),
                 InlineKeyboardButton("–í–ø–µ—Ä—ë–¥ ‚û°Ô∏è", callback_data="loyalty_history:next")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                response,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )
            
        except Exception as e:
            logger.error(f"Error in show_history: {e}")
            await update.message.reply_text(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏—Å—Ç–æ—Ä–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )
        finally:
            db.close()
    
    async def help_loyalty(self, update: Update, context: CallbackContext) -> None:
        """Show help message about loyalty commands."""
        help_text = """
üíé *–ë–æ–Ω—É—Å–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞*

–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
/balance - –ü–æ–∫–∞–∑–∞—Ç—å –±–∞–ª–∞–Ω—Å –±–∞–ª–ª–æ–≤ –∏ —É—Ä–æ–≤–µ–Ω—å
/earn <–±–∞–ª–ª—ã> [–ø—Ä–∏—á–∏–Ω–∞] - –ù–∞—á–∏—Å–ª–∏—Ç—å –±–∞–ª–ª—ã (–∞–¥–º–∏–Ω)
/spend <–±–∞–ª–ª—ã> [–ø—Ä–∏—á–∏–Ω–∞] - –°–ø–∏—Å–∞—Ç—å –±–∞–ª–ª—ã
/history - –ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π
/help_loyalty - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ

*–ö–∞–∫ –Ω–∞–∫–æ–ø–∏—Ç—å –±–∞–ª–ª—ã?*
- –°–æ–≤–µ—Ä—à–∞–π—Ç–µ –ø–æ–∫—É–ø–∫–∏
- –ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π
- –£—á–∞—Å—Ç–≤—É–π—Ç–µ –≤ –∞–∫—Ü–∏—è—Ö

*–£—Ä–æ–≤–Ω–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã:*
ü•â –ë—Ä–æ–Ω–∑–∞ - 0 –±–∞–ª–ª–æ–≤ (1% –∫—ç—à–±—ç–∫–∞)
ü•à –°–µ—Ä–µ–±—Ä–æ - –æ—Ç 1000 –±–∞–ª–ª–æ–≤ (3% –∫—ç—à–±—ç–∫–∞)
ü•á –ó–æ–ª–æ—Ç–æ - –æ—Ç 5000 –±–∞–ª–ª–æ–≤ (5% –∫—ç—à–±—ç–∫–∞)
üíé –ü–ª–∞—Ç–∏–Ω–∞ - –æ—Ç 10000 –±–∞–ª–ª–æ–≤ (10% –∫—ç—à–±—ç–∫–∞)
"""
        await update.message.reply_text(
            help_text,
            parse_mode='Markdown'
        )
    
    # Callback handlers
    async def handle_earn_callback(self, update: Update, context: CallbackContext) -> None:
        """Handle callback for earning points."""
        query = update.callback_query
        await query.answer()
        
        # Parse callback data
        _, user_id, points = query.data.split(':')
        user_id = int(user_id)
        points = int(points)
        
        db = next(get_db())
        try:
            # Get admin user
            admin = db.query(User).filter(
                User.telegram_id == update.effective_user.id
            ).first()
            
            if not admin or not admin.is_admin:
                await query.edit_message_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏.")
                return
            
            # Add points
            service = LoyaltyService(db)
            transaction = service.add_points(
                user_id=user_id,
                points=points,
                reason=f"–ù–∞—á–∏—Å–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º {admin.username or admin.telegram_id}",
                created_by=admin.id
            )
            
            # Get user
            user = db.query(User).get(user_id)
            
            # Format response
            response = (
                f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user.username or user.telegram_id} "
                f"–Ω–∞—á–∏—Å–ª–µ–Ω–æ *{points}* –±–∞–ª–ª–æ–≤\n"
                f"üí≥ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: *{service.get_balance(user_id)}* –±–∞–ª–ª–æ–≤"
            )
            
            await query.edit_message_text(
                response,
                parse_mode='Markdown'
            )
            
        except Exception as e:
            db.rollback()
            logger.error(f"Error in handle_earn_callback: {e}")
            await query.edit_message_text(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –±–∞–ª–ª–æ–≤."
            )
        finally:
            db.close()
    
    async def handle_spend_callback(self, update: Update, context: CallbackContext) -> None:
        """Handle callback for spending points."""
        # Implementation similar to handle_earn_callback
        # ...
        pass
    
    async def handle_history_callback(self, update: Update, context: CallbackContext) -> None:
        """Handle callback for pagination in transaction history."""
        # Implementation similar to show_history
        # ...
        pass

def register_handlers(application):
    """Register all loyalty command handlers."""
    loyalty_handlers = LoyaltyCommandHandlers()
    
    # Register command handlers
    for command, handler in loyalty_handlers.commands:
        application.add_handler(CommandHandler(command, handler))
    
    # Register callback handlers
    for callback_prefix, handler in loyalty_handlers.callbacks.items():
        application.add_handler(CallbackQueryHandler(
            handler, pattern=f'^{callback_prefix}:'
        ))
    
    return loyalty_handlers
